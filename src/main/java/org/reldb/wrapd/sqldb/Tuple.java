package org.reldb.wrapd.sqldb;

import org.reldb.toolbox.types.Pair;
import org.reldb.wrapd.exceptions.InvalidValueException;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The base class for all tuples. Derived classes are usually auto-generated by TupleTypeGenerator.
 */
public abstract class Tuple implements Serializable, Cloneable {

    private static final long serialVersionUID = 1L;

    /** Database used to create this Tuple. */
    protected final Database database;

    /** Backup made at time tuple is retrieved, prior to changing any fields. */
    private Tuple __backup = null;

    public Tuple(Database database) {
        this.database = database;
    }

    /**
     * Create backup, to facilitate identifying changed fields as part of update.
     *
     * @throws CloneNotSupportedException Thrown if creating clone() of Tuple fails.
     */
    public void backup() throws CloneNotSupportedException {
        __backup = (Tuple) super.clone();
    }

    /**
     * Obtain backup, to facilitate identifying changed fields as part of update.
     *
     * @return Backup Tuple.
     */
    public Tuple getBackup() {
        return __backup;
    }

    /**
     * Failure to retrieve a Field.
     */
    public static class FieldGetFailure {
        /** Field whose value we're trying to retrieve from a class instance. */
        public final Field field;
        /** Reason we couldn't retrieve the given field. */
        public final Throwable failure;
        /** Constructor. */
        FieldGetFailure(Field field, Throwable failure) {
            this.field = field;
            this.failure = failure;
        }
    }

    private Object fieldGetWrapper(List<FieldGetFailure> failures, Field field, Tuple tuple) {
        try {
            return field.get(tuple);
        } catch (Throwable t) {
            failures.add(new FieldGetFailure(field, t));
            return null;
        }
    }

    /**
     * Insert this Tuple.
     *
     * @param connection Connection to database, typically obtained via a Transaction.
     * @param tableName Table name.
     * @return List of failures to retrieve one or more fields. Empty if all fields retrieved.
     * @throws SQLException Failure.
     */
    public List<FieldGetFailure> insert(Connection connection, String tableName) throws SQLException {
        Supplier<Stream<Field>> dataFields = () -> TupleTypeGenerator.getDataFields(getClass());
        Supplier<Stream<String>> columns = () -> dataFields.get().map(Field::getName);
        var columnNames = columns.get().collect(Collectors.joining(", "));
        var parms = "?"
                .repeat((int) columns.get().count())
                .replaceAll(".(?!$)", "$0, ");
        var sql = "INSERT INTO " + database.replaceTableNames(tableName) + "(" + columnNames + ") VALUES (" + parms + ")";
        var fieldGetFailures = new LinkedList<FieldGetFailure>();
        var columnValues = dataFields
                .get()
                .map(field -> fieldGetWrapper(fieldGetFailures, field, this))
                .toArray(Object[]::new);
        if (fieldGetFailures.size() > 0)
            return fieldGetFailures;
        database.update(connection, sql, columnValues);
        return fieldGetFailures;
    }

    /**
     * Insert this Tuple.
     *
     * @param tableName Table name
     * @return List of failures to retrieve one or more fields. Empty if all fields retrieved.
     * @throws SQLException Failure.
     */
    public List<FieldGetFailure> insert(String tableName) throws SQLException {
        return database.useConnection(conn -> insert(conn, tableName));
    }

    /**
     * Update this tuple.
     *
     * @param connection Connection to database, typically obtained via a Transaction.
     * @param tableName Table name.
     * @return Return a pair of List&lt;FieldGetFailure&gt; where the left item is the new field
     *         get failures, and the right item is the original (backup) field get failures.
     *         Both lists in the Pair are empty if successful.
     * @throws SQLException Failure.
     */
    public Pair<List<FieldGetFailure>, List<FieldGetFailure>> update(Connection connection, String tableName) throws SQLException {
        var backup = getBackup();
        if (backup == null)
            throw new InvalidValueException("Tuple is not updatable. Tuples become updatable by invoking backup() after population and before mutation, usually by being obtained via Database::queryForUpdate or Database::queryAllForUpdate.");
        var fieldGetFailuresNew = new LinkedList<FieldGetFailure>();
        var fieldGetFailuresOld = new LinkedList<FieldGetFailure>();
        Supplier<Stream<Field>> dataFields = () -> TupleTypeGenerator.getDataFields(getClass());
        Supplier<Stream<Field>> changedFields = () -> dataFields.get().filter(field -> {
            var fieldNewValue = fieldGetWrapper(fieldGetFailuresNew, field, this);
            var fieldOldValue = fieldGetWrapper(fieldGetFailuresOld, field, backup);
            return !Objects.equals(fieldNewValue, fieldOldValue);
        });
        if (fieldGetFailuresNew.size() > 0 || fieldGetFailuresOld.size() > 0)
            return new Pair<>(fieldGetFailuresNew, fieldGetFailuresOld);
        var columnAssignments = changedFields
                .get()
                .map(field -> field.getName() + " = ?")
                .collect(Collectors.joining(", "));
        var key = database.getKeyColumnNamesFor(tableName);
        Supplier<Stream<Field>> rowPredicateSource = () -> (key == null) ? dataFields.get() : changedFields.get();
        var rowPredicate = rowPredicateSource
                .get()
                .map(field -> field.getName() + " = ?")
                .collect(Collectors.joining(" AND "));
        var sql = "UPDATE " + database.replaceTableNames(tableName) + " SET " + columnAssignments + " WHERE " + rowPredicate;
        var columnAssignmentNewValues = changedFields
                .get()
                .map(field -> fieldGetWrapper(fieldGetFailuresNew, field, this))
                .toArray();
        var rowPredicateValues = rowPredicateSource
                .get()
                .map(field -> fieldGetWrapper(fieldGetFailuresOld, field, backup))
                .toArray();
        if (fieldGetFailuresNew.size() > 0 || fieldGetFailuresOld.size() > 0)
            return new Pair<>(fieldGetFailuresNew, fieldGetFailuresOld);
        database.update(connection, sql, Database.allArguments(columnAssignmentNewValues, rowPredicateValues));
        return new Pair<>(fieldGetFailuresNew, fieldGetFailuresOld);
    }

    /**
     * Update this tuple.
     *
     * @param tableName Table name.
     * @return Return a pair of List&lt;FieldGetFailure&gt; where the left item is the new field
     *         get failures, and the right item is the original (backup) field get failures.
     *         Both lists in the Pair are empty if successful.
     * @throws SQLException Failure.
     */
    public Pair<List<FieldGetFailure>, List<FieldGetFailure>> update(String tableName) throws SQLException {
        return database.useConnection(conn -> update(conn, tableName));
    }
}
