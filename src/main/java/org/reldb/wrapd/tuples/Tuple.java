package org.reldb.wrapd.tuples;

import org.reldb.wrapd.exceptions.InvalidValueException;
import org.reldb.wrapd.sqldb.Database;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The base class for all tuples. Derived classes are usually auto-generated by TupleTypeGenerator.
 */
public abstract class Tuple implements Serializable, Cloneable {

    private static final long serialVersionUID = 1L;

    // Backup made at time tuple is retrieved, prior to changing any fields.
    private Tuple __backup = null;

    /**
     * Create backup, to facilitate identifying changed fields as part of update.
     */
    public void backup() throws CloneNotSupportedException {
        __backup = (Tuple) super.clone();
    }

    /**
     * Obtain backup, to facilitate identifying changed fields as part of update.
     */
    public Tuple getBackup() {
        return __backup;
    }

    /**
     * Insert this Tuple.
     *
     * @param database   - Database
     * @param connection - java.sql.Connection
     * @param tableName  - table name
     * @return - should return false
     * @throws SQLException on failure
     */
    public boolean insert(Database database, Connection connection, String tableName) throws SQLException {
        Supplier<Stream<Field>> dataFields = () -> TupleTypeGenerator.getDataFields(getClass());
        Supplier<Stream<String>> columns = () -> dataFields.get().map(Field::getName);
        var columnNames = columns.get().collect(Collectors.joining(", "));
        var parms = "?"
                .repeat((int) columns.get().count())
                .replaceAll(".(?!$)", "$0, ");
        var sql = "INSERT INTO " + database.replaceTableNames(tableName) + "(" + columnNames + ") VALUES (" + parms + ")";
        var columnValues = dataFields
                .get()
                .map(field -> {
                    try {
                        return field.get(this);
                    } catch (IllegalArgumentException | IllegalAccessException e) {
                        Database.log.error("ERROR: insert failed on field " + field.getName(), e);
                        return null;
                    }
                })
                .toArray(Object[]::new);
        return database.update(connection, sql, columnValues);
    }

    /**
     * Insert this Tuple.
     *
     * @param database  - Database
     * @param tableName - table name
     * @return - should return false
     * @throws SQLException on failure
     */
    public boolean insert(Database database, String tableName) throws SQLException {
        return database.useConnection(conn -> insert(database, conn, tableName));
    }

    /**
     * Update this tuple.
     *
     * @param database   - Database
     * @param connection - java.sql.Connection
     * @param tableName  - table name
     * @return - should return false
     * @throws SQLException on failure
     */
    public boolean update(Database database, Connection connection, String tableName) throws SQLException {
        var backup = getBackup();
        if (backup == null)
            throw new InvalidValueException("Tuple is not updatable. Tuples become updatable by invoking backup() after population and before mutation, usually by being obtained via Database::queryForUpdate or Database::queryAllForUpdate.");
        Supplier<Stream<Field>> dataFields = () -> TupleTypeGenerator.getDataFields(getClass());
        Supplier<Stream<Field>> changedFields = () -> dataFields.get().filter(field -> {
            Object fieldNewValue;
            Object fieldOldValue;
            try {
                fieldNewValue = field.get(this);
                fieldOldValue = field.get(backup);
                return !fieldNewValue.equals(fieldOldValue);
            } catch (IllegalArgumentException | IllegalAccessException e) {
                Database.log.error("ERROR: unable to compare old and new field values", e);
                return false;
            }
        });
        var columnAssignments = changedFields.get().map(field -> field.getName() + " = ?").collect(Collectors.joining(", "));
        var key = database.getKeyColumnNamesFor(tableName);
        Supplier<Stream<Field>> rowPredicateSource = () -> (key == null) ? dataFields.get() : changedFields.get();
        var rowPredicate = rowPredicateSource.get().map(field -> field.getName() + " = ?").collect(Collectors.joining(" AND "));
        var sql = "UPDATE " + database.replaceTableNames(tableName) + " SET " + columnAssignments + " WHERE " + rowPredicate;
        var columnAssignmentNewValues = changedFields.get().map(field -> {
            try {
                return field.get(this);
            } catch (IllegalArgumentException | IllegalAccessException e) {
                Database.log.error("ERROR: unable to retrieve new field value", e);
                return null;
            }
        }).toArray();
        var rowPredicateValues = rowPredicateSource.get()
                .map(field -> {
                    try {
                        return field.get(backup);
                    } catch (IllegalArgumentException | IllegalAccessException e) {
                        Database.log.error("ERROR: unable to retrieve predicate field value", e);
                        return null;
                    }
                }).toArray();
        return database.update(connection, sql, Database.allArguments(columnAssignmentNewValues, rowPredicateValues));
    }

    /**
     * Update this tuple.
     *
     * @param database  - Database
     * @param tableName - table name
     * @return - should return false
     * @throws SQLException on failure
     */
    public boolean update(Database database, String tableName) throws SQLException {
        return database.useConnection(conn -> update(database, conn, tableName));
    }
}
